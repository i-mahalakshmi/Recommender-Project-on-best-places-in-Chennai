# -*- coding: utf-8 -*-
"""RECOMMENDER PROJECT CODE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iBeI8GzlSiB4QkI5doYUAHG3BuIay59l

**PROJECT TITLE : UrbaneXplorer**
****

**MODEL : CONSTAINT BASED FROM KNOWLEDGE BASED SYSTEM**

DATASET collected manually from Trip Advisor and Holidify to gather information about each place
"""

import pandas as pd
import numpy as np

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/drive/MyDrive/recommender project/best_places_in_chennai.csv')
df.head()

!pip install pyOWM

"""**THE CONSTRAINT BASED MODEL FOR PLACE RECOMMENDATION IN A CITY TO EXPLORE**"""

from pyowm import OWM
import pandas as pd
import numpy as np

def build_chart(df):

  df = pd.read_csv('/content/drive/MyDrive/recommender project/best_places_in_chennai.csv')

  owm = OWM('0acc815c01034dd19d32548bed1d55bf')
  mgr = owm.weather_manager()
  observation = mgr.weather_at_place(input("enter the city name and country name: "))
  w = observation.weather
  tempData = w.temperature('celsius')
  atmosphere_num = 2

  if tempData['temp'] > 27:
    atmosphere_num = 1


  print("The input has to be only from the options provided inside brackets")
  print("Input preferred Segmentation(Games and Entertainment //  Religious sites //  Amusement & Theme  // Park&Gardens // Beaches //  Shopping Mall // Flea & Street Markets //Aquariums // Nature & Wildlife Areas // zoos // Museum // Library // Cultural attractions // Points of Interest & Landmarks // Park&Garden // flea & Street Markets // Bodies of Water // observatories &planetariums // churches&cathedrals // theatres // Art galleries // Antique Shops // Monuments & Statues // Entertainment // Sports camps // Theatre and Performances // Speciality and Gift shops //Equipment hire// Mini workshops )")
  pref_segmentation = input()

  #minimum cost
  print("It is the cost that You would defenitely require to visit the place. Ranges from 0 - 1800")
  print("Minimum cost you want to spend:")
  min_cost = int(input())

  #maximum cost
  print("Maximum cost you want to spend:")
  max_cost = int(input())


  print("The number of people the place can accomodate. Values ranges from 1-30,100 ")


  print("Maximum number of people you are going with")
  max_people = int(input())

  print("At what rating you wish the place should be(1.0/2.0/3.0/4.0/5.0):")
  review = float(input())

  print(tempData['temp'],atmosphere_num)

  filtered_df = df[(df['Segmentation'] == pref_segmentation) &
                       (df['approximate_cost'] >= min_cost) &
                       (df['approximate_cost'] <= max_cost) &
                    #  (df['no_of_people'] >= min_people) &
                       (df['no_of_people'] >= max_people) &
                       (df['review'] >= review)&
                       (df['atmosphere_num'] >= atmosphere_num)]


  return filtered_df
# filtered_df = build_chart(df)

"""**RESULT OF CONSTRAINT BASED PLACE RECOMMENDATION MODEL BASED ON USER PREFERENCE AND WEATHER CONDITION**"""

filtered_df = build_chart(df)


from tabulate import tabulate
print(tabulate(filtered_df))

"""**TO FIND THE SIMILARITY SCORE BETWEEN USER PREFERENCE AND THE RECOMMENDED PLACE BY THE MODEL**"""

from pyowm import OWM
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

def calculate_similarity(user_preferences, places_data):
    # Convert user preferences to a DataFrame
    user_df = pd.DataFrame([user_preferences])

    # Extract relevant features for similarity calculation
    features = ['approximate_cost', 'no_of_people', 'review', 'atmosphere_num']

    # Filter places_data to include only relevant features
    places_features = places_data[features]

    # Concatenate user_df and places_features for similarity calculation
    data_for_similarity = pd.concat([user_df, places_features], ignore_index=True)

    # Calculate cosine similarity
    similarity_matrix = cosine_similarity(data_for_similarity)

    # Extract similarity scores for each place
    similarity_scores = similarity_matrix[0, 1:]

    return similarity_scores

def recommend_similar_places(df, city, temperature, user_preferences):

    recommendations = build_chart(df)

    # Calculate similarity scores
    similarity_scores = calculate_similarity(user_preferences, recommendations)

    # Add similarity scores to recommendations DataFrame
    recommendations['similarity_score'] = similarity_scores

    # Sort recommendations by similarity score in descending order
    recommendations = recommendations.sort_values(by='similarity_score', ascending=False)

    return recommendations

if __name__ == "__main__":

    df = pd.read_csv('/content/drive/MyDrive/recommender project/best_places_in_chennai.csv')

    # Get user input for city and temperature
    city_name = input("Enter the city name and country name: ")
    temperature = float(input("Enter the current temperature: "))

    # Get user preferences input
    user_preferences = {
        'approximate_cost': float(input("Enter your preferred cost: ")),
        'no_of_people': int(input("Enter the number of people: ")),
        'review': float(input("Enter your preferred review rating: ")),
        'atmosphere_num': int(input("Enter the atmosphere type (1=outdoor or 2=(indoor,(indoor&outdoor)): "))
    }

    # Recommend similar places based on user preferences
    similar_recommendations = recommend_similar_places(df, city_name, temperature, user_preferences)

    # Display recommended places with similarity scores
    print("Recommended places with similarity scores:")
    print(similar_recommendations[['Name_of_Place', 'Segmentation', 'atmosphere_type', 'similarity_score']])



